"""This module is a command line wrapper around the distance module
"""

import argparse
import distances.metrics.cosine as cosine
import distances.metrics.kullback_leibler as kullback_leiber
import distances.metrics.dtw as dtw
import distances.distances as distances
import os
import functools

    
option_metrics = {'cosine': cosine.cosine_distance,
                  'kl_divergence': kullback_leiber.kl_divergence,
                  'js_divergence': kullback_leiber.js_divergence,
                  'kl_ptwise': kullback_leiber.kl_ptwise,
                  }


def dtw_distance(x, y, metric='cosine'):
    """Necessary redefinition for multiprocessing's pickle"""
    return dtw.dtw(x, y, option_metrics[metric])

if __name__ == '__main__':

    # parser (the usage string is specified explicitly because the default
    # does not show that the mandatory arguments must come before the
    # mandatory ones; otherwise parsing is not possible beacause optional
    # arguments can have various numbers of inputs)
    parser = argparse.ArgumentParser(description='ABX distance computation')

    # I/O files
    g1 = parser.add_argument_group('I/O files')
    g1.add_argument('features', help='feature file')
    g1.add_argument('task',
                    help='task file generated by the task module, '
                    'containing the triplets and the pairs associated to the task '
                    'specification')
    g1.add_argument('output',
                    help='Output distance file')
    # options
    g2 = parser.add_argument_group('options')
    g2.add_argument(
        '-n', '--ncpu', default=None, help='optional: number of cpus to use')
    g2.add_argument('-d', '--distance',
                    choices=option_metrics.keys(),
                    default='cosine',
                    help='optional: metric to use. By default, a cosine distance '
                    'will be used')

    args = parser.parse_args()

    if os.path.exists(args.output):
        print("Warning: overwriting distance file {}".format(args.output))
        os.remove(args.output)
    distances.compute_distances(args.features, '/features/', args.task,
                                args.output,
                                functools.partial(dtw_distance, metric=args.distance),
                                n_cpu=args.ncpu)
